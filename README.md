# Elixir-2023

## IEx

- IEX.helpers
- h 関数
- アリティ
- モジュールを指定するとモジュールのドキュメントが見られる
- 関数を指定すると関数のドキュメントが見られる

## Elixirの型 (basic)

- integer
- float
- atom
- boolean value
- nil
- bitstring
- binary
- string
- list
- charlist
- keyword list
- tuple
- map
- function
- Process ID
- reference
- port identifier

## データ型

- 前項と同じ

## 数値

### integer

- 整数
- 大きい数値はアンダースコアで区切れる
  - 例：```1_000_000```
- 16, 8, 2 進数表記ができる
  - 0x
  - 0o
  - 0b

### float

- 浮遊動小数点数
- e: 指数
  - 指数が0の場合は省略可能

### atom

- 自分自身の名前がそのまま定数になる
- コロンをつける
- アルファベット, _, @ が使える
- 末尾では ?, ! が使える
- 役割は今後具体例を見ながら学ぶ

### string

- 文字列
- ダブルクォーテーションで囲む
- エスケープ文字が使える
  - 例：```\n```
- シングルクォーテーションで囲むと文字列リストになってしまう
- 連結 ```<>```
- 補完 ```#{}```

### list

- データの集合
- 同じ型でなくてもよい
- 連結リスト -> 先頭への追加の方が速い
- 連結 ```++```
- 差分 ```--```
- 包含 ```in```, ```not in```
- 追加 ```[head | tail]``` tail はリスト

### tuple

- 主に2から4個程度のデータの集合を扱う
  - それ以上は map
- 連結、差分はとれない
- メモリ上で隣接している
  - 長さの取得が速い
  - 修正は高コスト
  - 他言語の配列

### keyword list

- 要素が全てタプルである
- タプルの要素数は2である
- タプルの第一要素がアトムである
- 簡易記法

``` elixir
list = [name: "hoge", age: 1]
list[:name]　# hoge
```

### map

- unorderdedMap
- ```%{key => value}```
- key がアトムの場合は ```map.key``` で value を取得できる

## Day1 Section 3

### 関数

- anonymous と named がある
- 例

``` elixir
add = fn a, b -> a + b end
x = add.(1, 1)
```

### 型の判別

- is_型の名前/1 で判別できる

### 無名関数

- fn で始まり end で終わる
- ドット(.) は関数の呼び出しを意味する

### 名前付き関数

- def で始まり end で終わる
- 原則小文字のアルファベットで始める
- 例

``` elixir
defmodule Math do
  def calc(x, y) do
    x * 3 + y
  end
end
```

- defmodule については次項で解説

### モジュール

- 関数をグループ分けする単位
- 全ての named function は1つのモジュールに属する
- 原則、モジュール名は大文字のアルファベットで始める

#### 名前付き関数の呼び出し

- elixirc でコンパイル
- コンパイルしたら .beam ファイルができる

### 無名関数の作成と呼び出し

- 仮引数は括弧をつけないのが一般的
- 変数にセットせずに使うこともできる
- 例

``` elixir
iex> (fn a, b -> a * b end).(3,5)
15
```

### キャプチャ演算子

- named function を named function のように扱う
- ```&``` で表現する
- 例1

``` elixir
f = &Math.calc/2
f.(1, 3)

func = &Math.calc(&1, &2)
func.(1, 3)
```

- 例2

``` elixir
func = &([&1 | [1, 2, 3]])
func.(0)
```

### 構造体

- 特殊な map
  - デフォルト値を持つ
  - キーはアトム
  - モジュール内で定義する
- defstruct で定義する

#### 構造体の取得

- ```%Hoge{}``` の形で呼び出せる
- ```hoge.key``` か ```Map.get(hoge, :key)``` で値を取り出す
  - ```hoge[:key]``` はエラー

#### エラーの発生

- 定義されてないキーで呼び出すとエラー
- モジュールで定義されていないキーを追加できない

#### nil の定義

- フィールド値を ```nil``` で定義できる

#### 関数を使用しての更新

- Map.put
- Map.replace

## Elixir基礎ワーク

### 標準入出力

- trim/1 で空白改行を除くことができる

### 四則演算

- div integer 型の商
- rem 余り

### 文字列とアトム

- boolean の true, false は実はアトムの :true, :false
- 厳密等価演算子 ```===```
- 大文字始まりはアトムとして評価される
  - ```Elixir.Hoge``` のように ```Elixir``` が補完されている

### 文字リスト

- シングルクォーテーションで囲む
- 32~126 の値のみを含むリストは文字リストとして評価される
- 例

``` elixir
[97, 98, 99] == 'abc'
# true
```

### リスト/タプル/マップ

- マップのキーが衝突する場合最後の要素のみがキーとして定義される
- コレクションに対する操作は公式が出している関数がいくつもある

## Day2 Section1

### 変数

- Elixir の変数は一般的なプログラミング言語の箱のイメージとは異なる

### パターンマッチ

- ```=``` はパターンマッチを行う二項演算子
- 左辺をパターンと呼ぶ
- ```=``` はパターンマッチに成功すると右辺の値を返す

### 変数への束縛

- 一般的なプログラミング言語の代入とは本質的に異なる
- この違いによる影響は先のチャプターで学ぶ

### 変数への再束縛

- ```x = x + 5``` で再束縛できる
- Erlang や Haskell では禁止されている

### パターンマッチの活用

- ```[a, 2, c] = [1, 2, 3]``` で ```a```, ```c``` が束縛される
- タプルも同様

### パターンマッチ上のアンダースコア

- アンダースコアは特別な変数
  - 束縛された値を全て捨てる
  - どんな値ともマッチする

### アンダースコアから始まる変数

- 参照されることがない変数はアンダースコアから始める
- 例：```_x = 1```
- 参照しようとすると警告が出る

### 値の不変性

- Elixir の値は不変
- リストに値を追加するときはコピーが作成される
  - 元のリストを他で参照しているコードに影響を与えない
- コピーを作成することで非効率になることはない（原理は割愛）
- 自主的に試してみた (Day2_Section2/immutability.exs)

## Day2 Section2

### 制御構造

#### if

- ```if 条件式 do 処理 end``` の形
- 条件式が true の場合 end まで実行する

#### if ･ else

- ```if 条件式 do 処理1 else 処理2 end``` の形
- 条件式が true の場合、処理1を実行する
- 条件式が false の場合、処理2を実行する

#### unless

- if の逆

#### unless ･ else

- if ･ else の逆

#### case

- 以下の形

``` elixir
case {1, 2, 3} do
  {4, 5, 6} -> "No match"
  {1, x, 3} -> "Match"
  _ -> "_ match all conditions"
end
```

- 条件にマッチするまで値を比較する
- 事前に束縛した変数と比較したいときは ```^``` を変数の前につける

#### Guard 節

- 引数によって処理を分ける
- case 文中で ```パターン when 条件式 -> 処理``` の形

#### cond

- 最初にマッチするものを探す
- 以下の形

``` elixir
cond do
  2 + 2 == 5 -> "First,not true"
  2 * 2 == 3 -> "Second,false"
  1 + 1 == 2 -> "Third,true!!"
end
```

- どれにもマッチしない場合エラー

#### do / end ブロック

- シンタックスシュガー ```if hoge, do: fuga, else: piyo```
- ```do:``` の後にはスペースを入れる
- 最も外側の関数に対してバインドされる
